## 进程的虚拟内存是如何分配的？
### MMU
每一个进程都有一个虚拟的，独立的内存空间，从00000-MAX。为了达到这个目标，我们为每一个进程设置一个MMU，MMU的功能是将虚拟的内存地址和真实的内存地址家里起一个对应。

MMU的本质是一个3层的512叉树，树的节点被称作PTE，功能是将64位的虚拟地址（下文简称VA）和56位的物理地址（下文简称PA）一一对应。
### MMU的运行原理
对于64位的VA，我们将它拆成25+9+9+9+12；对于56位的物理地址PA，我们将它拆成44+12。VA中的后12位与PA中的后12位完全相同，直接等价，这对应OS中页的概念（$2^{12}=4KB$)。VA中的前25位直接舍弃。而对于中间的9+9+9，就分别对应了MMU的3层512叉树（$2^9=512$)。

MMU作为树是动态生长的，即最开始并不存在一个完整的3层512叉树，而是虚拟地址进入MMU后被创建的。而创建的过程如下图所示

### 虚拟内存映射图

![[virtual address to physical address.png]]
图中PPN就是Physical Page Number的缩写，后面的10位RSW D A G U X W R V 就是Flags，第一层和第二层的PPN是为了找到后面一个tree在哪里的，而最后一个PPN决定了最终的物理地址PA（physical address)。

## 物理内存与虚拟内存的全局对应关系
### 物理内存与虚拟内存映射的全局映射关系图
![[global memory mapping.png]]
#### 硬件驱动存储区
由图可以观察到，物理内存的最底层1000是不用的，ROM是只读内存，属于系统核心文件。在0x02000000才开始使用。而到KERNBASE线前，这部分的内存属于硬件驱动程序，虚拟地址和实际地址意一一对应。
#### 内核存储区
在kernbase到Phystop之间的程序就是内核程序，也就是我们熟悉的操作系统所存储的地方，这里的虚拟地址和物理地址一一对应（从中我们可知内核态的程序所谓的全知视角，所谓可以看到物理内存，根本原因是他们的虚拟内存和物理内存是一一对应的，故而内核进程可以说自己决定的是真实地址）
#### 进程存储区
在kernbase这条线之上，也就是一个进程以为自以为自己拥有的内存，但实际是经过MMU分配的结果，而值得注意的是每个进程的顶层，即Trampoline（蹦床）都指向了内核的同一个位置，这是方便操作系统对各个进程的控制。

## 进程内内存的分布
### 进程内内存分布图
![[user's memory.png]]
这张图里stack和heap的位置和一般的操作系统相反，一般的布局是stack在上向下生长，而heap从下往上生长。这张图其他的信息比较明确就不做解释了。